=====================================================================================
Docker란?
=====================================================================================
컨테이너라는 개념은 도커가 처음 만든 것이 아닙니다. 도커가 등장하기 이전에, 프로세스를 격리하는 방법으로 리눅스에서는 cgroups(control groups)와 namespace를 이용한 LXC(Linux container)가 있었고 FreeBSD에선 Jail, Solaris에서는 Solaris Zones이라는 기술이 있었습니다. 구글에서는 고오오급 기술자들이 직접 컨테이너 기술을 만들어 사용하였고 lmctfy(Let Me Contain That For You)라는 뭐라고 읽어야 할지 알 수 없는 오픈소스 컨테이너 기술을 공개했지만 성공하진 못함.도커는 LXC를 기반으로 시작해서 0.9버전에서는 자체적인 libcontainer 기술을 사용하였고 추후 runC기술에 합쳐졌습니다.
이미지는 컨테이너 실행에 필요한 파일과 설정값등을 포함하고 있는 것으로 상태값을 가지지 않고 변하지 않습니다(Immutable). 컨테이너는 이미지를 실행한 상태라고 볼 수 있고 추가되거나 변하는 값은 컨테이너에 저장됩니다. 같은 이미지에서 여러개의 컨테이너를 생성할 수 있고 컨테이너의 상태가 바뀌거나 컨테이너가 삭제되더라도 이미지는 변하지 않고 그대로 남아있습니다.
도커 이미지는 Public Registry: docker hub에 등록하거나 Private Registry: docker Registry 저장소, Local(Host) Registry 를 직접 만들어 관리할 수 있습니다. 
컨테이너, 오버레이 네트워크overlay network, 유니온 파일 시스템union file systems등 이미 존재하는 기술을 도커처럼 잘 조합하고 사용하기 쉽게 만든 것은 없었고 사용자들이 원하는 기능을 간단하지만 획기적인 아이디어로 구현하였습니다.
도커는 이런 문제를 해결하기 위해 레이어layer라는 개념을 사용하고 유니온 파일 시스템을 이용하여 여러개의 레이어를 하나의 파일시스템으로 사용할 수 있게 해줍니다. 
도커는 이미지를 만들기 위해 dockerfile이라는 파일에 자체 DSLDomain-specific language언어를 이용하여 이미지 생성 과정을 적습니다. 
도커는 리눅스 컨테이너 기술이므로 macOS나 windows에 설치할 경우 가상머신에 설치가 됩니다. 리눅스 컨테이너 말고 윈도우즈 컨테이너라는 것도 존재하지만 여기서는 다루지 않습니다. 도커를 맥이나 윈도우즈에 설치하려면 docker for mac 또는 docker for windows를 설치하면 됩니다. 
도커를 실행하는 명령어는 다음과 같습니다.

docker container run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]

다음은 자주 사용하는 옵션들입니다.

옵션		설명
-d		detached mode 흔히 말하는 백그라운드 모드
-p		호스트와 컨테이너의 포트를 연결 (포워딩)
-v		호스트와 컨테이너의 디렉토리를 연결 (마운트)
-e		컨테이너 내에서 사용할 환경변수 설정
–name	컨테이너 이름 설정
–rm		프로세스 종료시 컨테이너 자동 제거
-it		-i와 -t를 동시에 사용한 것으로 터미널 입력을 위한 옵션
–link		컨테이너 연결 [컨테이너명:별칭]

엄청나게 직관적인 옵션으로 몇번 실행해보면 자연스럽게 익숙해집니다.

//kubernetes == docker + Dockerfile + docker-compose + Docker Stack + docker swarm + CNI/CSI Plus alpha

=====================================================================================
설치상태 확인
====================================================================================

docker --version
Docker version 19.03.8, build afacb8b7f0

docker version
root@srv161:~# docker version
Client: Docker Engine - Community
 Version:           20.10.16
 API version:       1.41
 Go version:        go1.17.10
 Git commit:        aa7e414
 Built:             Thu May 12 09:17:28 2022
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.16
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.17.10
  Git commit:       f756502
  Built:            Thu May 12 09:15:33 2022
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.6.4
  GitCommit:        212e8b6fa2f44b9c21b2798135fc6fb7c53efc16
 runc:
  Version:          1.1.1
  GitCommit:        v1.1.1-0-g52de29d
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
root@srv161:~#


mkbahk@srv161:~$ sudo systemctl status docker*
● docker.service - Docker Application Container Engine
   Loaded: loaded (/etc/systemd/system/docker.service; enabled; vendor preset: enabled)
  Drop-In: /etc/systemd/system/docker.service.d
           └─mount_propagation_flags.conf
   Active: active (running) since Sat 2022-06-04 15:03:11 KST; 20h ago
     Docs: http://docs.docker.com
 Main PID: 41779 (dockerd)
    Tasks: 108
   CGroup: /system.slice/docker.service
           ├─35736 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 54320 -container-ip 172.17.0.4 -container-port 5432
           ├─41779 /usr/bin/dockerd
           └─47091 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 8989 -container-ip 172.17.0.3 -container-port 80

//명령어 도움말
docker --help
docker container --help
docker container rm --help

//모든 것들이 정상적으로 수행중이면
##Interactive Program 수행 예
docker container run hello-world:latest  

##Service/Daemon Program 기동예
docker container run -it -d -p 80:80 --name nginxweb nginx:latest
##browser열어서
http://192.168.56.202/


//Docker GUI 관리도구 설치
docker volume create portainer_data
docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest
##접근
https://192.168.56.202:9443

UserID: admin
Password: 12자리 이상 길게


=====================================================================================
Docker 핵심명령어
=====================================================================================
[핵심 4개 명령어-프로그램, computing, storage, Network]
docker image
docker container
docker volume
docker network 

docker image pull/push
docker image ls (== docker images)
docker container ls (== docker container ps, docker ps, kubectl get pods)
docker container ls -a
docker container logs nginxweb (kubectl logs)
docker container inspect nginxweb (kubectl describe)
docker container inspect --format '{{.NetworkSettings.IPAddress}}' nginxweb
docker volume ls (kubectl get pv)
docker network ls

docker container run (kubectl run)
docker container attach [container_name] (kubectl attach)  
//콘솔에 접속함. 주의 "exit"하면 daemon 도 죽음, Ctrl-P,Q로 나와야 함. 

docker container exec -it [container_name] [컨터이너_내부명령어]  (kubectl exec)
//ex) /bin/bash 등 shell 수행시 새로운 터미널을 여는 것임. exit 명령으로 나와도 daemon 상태일때는 죽지 않음.

docker container top nginxweb (kubectl top {node|pod})

docker stop nginxweb
docker start nginxweb

//docker container 의 3가지 상태
  1) image상태   ##docker image ls
  2) running container상태  ##docker container ls
  3) stopped container상태 ##docker container ls -a, 모든 설정정보도 같이 보관 중이라 start시키면 이전 상태정보로 바로 수행가능, 이 상태정보와 새로 수행되는 컨터이너의 상태정보를 중복되면 않됨


docker image rm(==docker rmi) //image 삭제
docker container rm (==docker rm)  //container 삭제
docker volume rm
docker network rm

//실행 중인 컨테이너들에게 영향을 주지 않음
docker image prune  //docker image rm -f $(docker image ls -aq)
docker container prune  // docker container rm -f $(docker container ls -aq)
docker volume prune
docker network prune
docker system prune -a  //system초기화, 기 수행중인 컨테이너 관련 내용이나 특히, 특이하게 "volume"은 지우지 않음

=====================================================================================
Docker & Kubectl 명령어 연관성
=====================================================================================
kubectl --help
kubectl controls the Kubernetes cluster manager.

Find more information at: https://kubernetes.io/docs/reference/kubectl/overview/

Basic Commands (Beginner):
  run           Run a particular image on the cluster

Basic Commands (Intermediate):
  delete        Delete resources by filenames, stdin, resources and names, or by resources and label selector

Cluster Management Commands:
  top           Display Resource (CPU/Memory/Storage) usage.

Troubleshooting and Debugging Commands:
  describe      Show details of a specific resource or group of resources
  logs          Print the logs for a container in a pod
  attach        Attach to a running container
  exec          Execute a command in a container
  cp            Copy files and directories to and from containers.


Usage:
  kubectl [flags] [options]

Use "kubectl <command> --help" for more information about a given command.
Use "kubectl options" for a list of global command-line options (applies to all commands).


=====================================================================================
프로그램 기동방법 3가지
=====================================================================================
1. Interactive: docker가 제공
2. Service(Daemon): docker, docker-compose, docker-swarm이 제공
3. Schedule job: kubernetes가 위 1, 2 + 제공

=====================================================================================
Docker 기초 실습
=====================================================================================
echo "Hello World" 
docker container run  busybox:latest echo "Hello World"
docker container run -it ubuntu:latest echo "Hello World"
docker container run -it ubuntu:latest cat /etc/lsb-release
docker container run -it ubuntu:latest bash
	cat /etc/lsb-release
	echo "Hello World"
	exit

docker container run -it centos:latest echo "Hello World"
docker container run -it centos:latest cat /etc/centos-release
docker container run -ti centos:latest bash
	cat /etc/centos-release
	echo "Hello World"
	exit

docker container run -it busybox sh
	busybox
	busybox | head -n 10
 	busybox | grep ping

docker container run -it ubuntu:latest ping 8.8.8.8
docker container run -it centos:latest ping 8.8.8.8
docker container run -it busybox ping 8.8.8.8

docker container run -it ubuntu:latest bash
	apt update
	apt install iputils-ping
	ping 8.8.8.8
	exit

docker container run -it ubuntu:latest ping 8.8.8.8  //???

PS C:\Users\mkbah> docker container ls -a
CONTAINER ID   IMAGE             COMMAND                  CREATED             STATUS                         PORTS                     NAMES
c61fd94c8b29   ubuntu:latest     "ping 8.8.8.8"           18 seconds ago      Created                                                  modest_swirles
e9e99be2481c   ubuntu:latest     "bash"                   9 minutes ago       Exited (137) 2 minutes ago                               eager_mcnulty
e77a1c2e883e   busybox:latest    "ping 8.8.8.8"           10 minutes ago      Exited (0) 10 minutes ago                                friendly_nightingale

docker container run -it e9e99be2481c bash	//???

docker exec -it e9e99be2481c bash bash 	//???
docker start e9e99be2481c
docker exec e9e99be2481c ping 8.8.8.8


=====================================================================================
Docker container 리소스 제한 및 모니터링
=====================================================================================

docker container run -d -m 512m nginx:latest 
docker container run -d --cpus="0.5" nginx:latest
##여러개 수행해 보세요. 내부 포트 80번은 중복되어도 문제없음

docker container run -d --device-write-bps /dev/sda:1mb ubuntu:18.04 sleep 100000

docker container stats [Container_Name]

//시스템 관리자가 상시 모니터링하는 명령
docker stats ##수행중인 모든 컨테이너들의 각각 자원사용량 표시
docker events ##각종 도커시스템 이벤트를 출력

//web gui로 리소스 모니터링
https://github.com/google/cadvisor


=====================================================================================
Docker Snapshot, Backup & Restore
=====================================================================================
docker commit e9e99be2481c mkbahk/ubuntuwithping
docker save mkbahk/ubuntuwithping:latest -o ubuntuwithping.docker.image

PS C:\Users\mkbah> docker container ls -a
CONTAINER ID   IMAGE                          COMMAND                  CREATED             STATUS                      PORTS                     NAMES
633a6c56dbc5   mkbahk/ubuntuwithping:latest   "ping 8.8.8.8"           21 seconds ago      Exited (0) 16 seconds ago                             inspiring_volhard

docker container prune

docker load -i .\ubuntuwithping.docker.image
docker container run -it mkbahk/ubuntuwithping:latest ping 8.8.8.8
docker rm 633a6c56dbc5
docker container ls

docker image ls

PS C:\Users\mkbah> docker image ls
REPOSITORY              TAG         IMAGE ID       CREATED          SIZE
mkbahk/ubuntuwithping   latest    4766280c184f   12 minutes ago   113MB
postgres                latest    5b21e2e86aab   6 days ago       376MB

docker rmi mkbahk/ubuntuwithping:latest

//export/import: container 저장, save/load: image저장
Docker export --> docker import
  docker export nginxweb > nginxweb.tar
  docker import nginxweb.tar

Docker save --> docker load
  ##수행/Stopped 컨테이너는 반드시 commit 후 save/load
  docker commit
  docker save
  docker load

//참고: docker image 파일을 가지고 다니는 것 보다는 Dockerfile, compose, stack등 script형태로 지참, 전달하는 것이 바람직

=====================================================================================
Public Registry 에 등록 push/pull
=====================================================================================
docker tag mkbahk/ubuntuwithping:latest {public:docker.io | private:IP_Address}/mkbahk/ubuntuwithping:1.9
docker login   ##dockerhub.com 에 로그인해야 함.
docker push mkbahk/ubuntuwithping:latest

##dockerhub.com 의 자신의 ID에서 리스트 확인

docker pull mkbahk/ubuntuwithping:latest
docker container run -it mkbahk/ubuntuwithping:latest ping 8.8.8.8
Ctrl-c

docker container run mkbahk/ubuntuwithping:latest ping 8.8.8.8
Ctrl-c  // stop이 불가

docker container run hello-world
docker image lsPS C:\Users\mkbah> docker container ls
CONTAINER ID   IMAGE                          COMMAND                  CREATED          STATUS          PORTS                     NAMES
2a6dd1553358   mkbahk/ubuntuwithping:latest   "ping 8.8.8.8"           49 seconds ago   Up 48 seconds                             friendly_antonelli
5d30aff0cc02   postgres:latest                "docker-entrypoint.s…"   2 hours ago      Up 2 hours      0.0.0.0:49153->5432/tcp   postgres-Hr9o
PS C:\Users\mkbah> docker stop 2a6dd1553358
2a6dd1553358

//이미지가 없으면 로컬시스템repository에서 찻고, 없으면 Local Private Repository, 없으면 Public Repository(dockerhub.com)에서 찾아서, 다운로드하고, 실행시키는 명령
docker container run -it mkbahk/ubuntuwithping:latest ping 8.8.8.8

=====================================================================================
Docker상에 S/W 개발환경 구성
=====================================================================================
//python, tensorflow, jypyter notebook 설치
docker run -it --rm -v $(realpath ~/notebooks):/tf/notebooks -p 8888:8888 tensorflow/tensorflow:latest-jupyter
##처음부터 daemon으로 띄우지 마세요. 콘솔메세지 보면 초기 아래와 같이 Token값이 표시되고 이용해 새로운 패스워크 입력이 가능합니다.


    To access the notebook, open this file in a browser:
        file:///root/.local/share/jupyter/runtime/nbserver-1-open.html
    Or copy and paste one of these URLs:
        http://06fc6c252964:8888/?token=07ba6372a9711bcf4688138b7f25b1e4c13c3b5008ac5e3c
     or http://127.0.0.1:8888/?token=07ba6372a9711bcf4688138b7f25b1e4c13c3b5008ac5e3c

##접근
http://192.168.56.202:8888/?token=07ba6372a9711bcf4688138b7f25b1e4c13c3b5008ac5e3c


//이제부터는 메모리부족 현상 나오니 자주 "docker system prune -a"로 불필용한 자원 삭제합니다.


//python, tensorflow, Visual Studio Code환경
docker run -it tensorflow/tensorflow:latest bash

apt install nano wget git -y
curl -fsSL https://code-server.dev/install.sh | sh

cd
code-server  ##일단 한번 기동시켜 기본 설정파일을 얻습니다.

cd .config/code-server
ls -al

root@d563f39ea80d:~/.config/code-server# cat config.yaml
bind-addr: 127.0.0.1:8080
auth: password
password: e8bb46222a042ddb2c4efe24
cert: false

//원격접근이 가능하도록 ip_address와 암호를 기억하기 쉬운 것으로 변경하세요.
root@d563f39ea80d:~/.config/code-server# nano config.yaml
bind-addr: 0.0.0.0:8080
auth: password
password: P@ssw0rd
cert: false

root@d563f39ea80d:~# code-server
[2022-06-08T09:35:51.029Z] info  code-server 4.4.0 b088ec7adf9e17bc75215f79e21498eb40da03ed
[2022-06-08T09:35:51.030Z] info  Using user-data-dir ~/.local/share/code-server
[2022-06-08T09:35:51.038Z] info  Using config file ~/.config/code-server/config.yaml
[2022-06-08T09:35:51.038Z] info  HTTP server listening on http://0.0.0.0:8080/
[2022-06-08T09:35:51.038Z] info    - Authentication is enabled
[2022-06-08T09:35:51.038Z] info      - Using password from ~/.config/code-server/config.yaml
[2022-06-08T09:35:51.038Z] info    - Not serving HTTPS

Ctrl+C or Exit

docker container ls -a
mkbahk@srv161:~$ docker container ls -a
CONTAINER ID   IMAGE                                COMMAND                  CREATED             STATUS                      PORTS                                                  NAMES
d563f39ea80d   tensorflow/tensorflow:latest         "bash"                   6 minutes ago       Exited (0) 6 seconds ago                                                           interesting_mcnulty



docker commit d563f39ea80d mkbahk/tensorflow:code-server-8080

docker run -it -p 8080:8080 mkbahk/tensorflow:code-server-8080 code-server


//postgresql 설치

docker container run -d -p 5432:5432 -e POSTGRES_PASSWORD=posgrespw --name postgres postgres:latest
docker container exec -it postgres /bin/bash
  psql -h localhost -U postgres -w
  select version();


외부에서 DBeaver를 통해서 접속합니다.
Connection String: postgres://postgres:postgrespw@192.168.56.202:5432

  CREATE TABLE public.HelloTable (
    id 		int PRIMARY KEY NOT NULL,
    name	text NOT NULL,
    age		int NOT NULL,
    address char(50),
    salary	REAL
  );

  select * from public.HelloTable;

  insert into public.HelloTable (id, name, age ) values 
    (3, 'Bahk, Sang-Bong', 80),
    (2, 'Bahk, Kee-Berm', 20),
    (1, 'Bahk, Moon-Kee', 50);

  select * from public.HelloTable;

  drop table public.HelloTable;

//zeppelin
docker container run -d -p 8080:8080 --link postgres:postgres --name zeppelin apache/zeppelin:0.10.1
 
docker exec -it zeppelin /bin/bash
  cd /var/lib/postgresql/data#

nano pg_hba.conf
  #md5 --> trust
  host    all             all             all                     trust 
  #

##zeppelin jdbc interpreters 설정변경
  Properties
  Name	Value	Description
  default.url	jdbc:postgresql://172.17.0.4:5432/postgres	The URL for JDBC.
  default.user	postgres	The JDBC user name
  default.password	***	The JDBC user password



//mysql 설치 및 서비스 수행, 암호없이 접속 + wordpress 설치 및 mysql와 연결 / -p 3306(호스트):3306(도커내부)
docker container run -d -p 3306:3306 --name mysql mysql:latest
##수행이 되지 않습니다.
docker container la -a

root@srv161:~# docker container ls -a
CONTAINER ID   IMAGE                           COMMAND                  CREATED         STATUS                     PORTS                                                                                            NAMES
26de0eaa8378   mysql:latest                    "docker-entrypoint.s…"   2 minutes ago   Exited (1) 2 minutes ago                                                                                                    mysql
988ca359431f   jenkins/jenkins:latest          "/usr/bin/tini -- /u…"   15 hours ago    Up 15 hours                50000/tcp, 0.0.0.0:8282->8080/tcp, :::8282->8080/tcp                                             goofy_cartwright
a2f0ff8d4426   portainer/portainer-ce:latest   "/portainer"             11 days ago     Up 15 hours                0.0.0.0:8000->8000/tcp, :::8000->8000/tcp, 0.0.0.0:9443->9443/tcp, :::9443->9443/tcp, 9000/tcp   portainer

docker logs 26de0eaa8378

oot@srv161:~# docker logs 26de0eaa8378
2022-06-22 23:08:56+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.29-1debian10 started.
2022-06-22 23:08:56+00:00 [Note] [Entrypoint]: Switching to dedicated user 'mysql'
2022-06-22 23:08:56+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.29-1debian10 started.
2022-06-22 23:08:56+00:00 [ERROR] [Entrypoint]: Database is uninitialized and password option is not specified
    You need to specify one of the following:
    - MYSQL_ROOT_PASSWORD
    - MYSQL_ALLOW_EMPTY_PASSWORD
    - MYSQL_RANDOM_ROOT_PASSWORD

ocker container rm 26de0eaa8378

docker container run -d -p 3306:3306 -e MYSQL_ALLOW_EMPTY_PASSWORD=true --name mysql mysql:latest
docker exec -it mysql bash
	mysql -u root -p
	Enter  //password가 없습니다.
	show databases;
	use mysql;
	show tables;
	select * from user;
	exit
	exit

docker stop a6e548864a75
docker container rm a6e548864a75

//wordpress를 위한 mysql 설치
docker container run -d --name mysql -v mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=wordpress -e MYSQL_DATABASE=wordpress -e MYSQL_USER=wordpress -e MYSQL_PASSWORD=wordpress mysql:5.7
//wordpress 설치 및 mysql 연결
docker container run -d --name wordpress --link mysql:mysql -v wordpress:/var/www/html -e WORDPRESS_DB_HOST=mysql:3306 -e WORDPRESS_DB_USER=wordpress -e WORDPRESS_DB_PASSWORD=wordpress -p 8989:80 wordpress:latest

docker container stop
docker container rm
docker system prune -a 

=====================================================================================
Docker Container와 Host간의 파일 교환
=====================================================================================
docker container run -d -p 5432:5432 -e POSTGRES_PASSWORD=posgrespw --name postgres postgres:latest

//파일 Upload, Download
//host -> Container
docker cp ./dvdrental.zip postgres:/tmp/dvdrental.zip

docker exec -it postgres-Hr9o bash
	cd /tmp
	ls -al
  exit

//container -> host 
docker cp postgres:/tmp/dvdrental.zip  . 
ls -al

=====================================================================================
docker volume으로 마운트
=====================================================================================
//docker에 Volume Mount
docker volume create hostvol
docker volume ls
docker volume inspect hostvol

root@srv161:~# sudo ls -al /var/lib/docker/volumes
total 76
drwx------ 11 root root  4096  6월  4 18:46 .
drwx--x--x 14 root root  4096  6월  4 15:03 ..
drwxr-xr-x  3 root root  4096  6월  4 17:16 49006234c749e913038abd2944d5c0f86e7afd10f7307090146ca66a4fca7068
drwxr-xr-x  3 root root  4096  6월  4 17:16 6043736fd514fe72222593c1b13bde271af77d82ed924c47eef9b4d1e29ce6e6
drwxr-xr-x  3 root root  4096  6월  4 18:19 8bc53954fc3d784aa7c6af200ca71791c80cf961c3c8907cc5bdf2114a1d3a00
drwxr-xr-x  3 root root  4096  6월  4 18:21 a4e13aa9d83c119e8538632a1cd80d248f8ef570c2a0de04cf6486f841c2a190
drwxr-xr-x  3 root root  4096  6월  4 18:18 aedf123be47bbc0e3fc02615535d0993790e311ff1720929268b5f968ac5ced9
drwxr-xr-x  3 root root  4096  6월  4 18:46 hostvol
-rw-------  1 root root 65536  6월  4 18:46 metadata.db
drwxr-xr-x  3 root root  4096  6월  4 14:42 mysql
drwxrwxrwx  3 root root  4096  6월  4 18:39 pgdata
drwxr-xr-x  3 root root  4096  6월  4 14:44 wordpress

docker container run -it --rm -v hostvol:/mnt/hostvol --name ubuntu00 ubuntu:18.04 bash
	cd /mnt/hostvol
	echo "Created by ubuntu00" >> ubuntu00.txt
	ls -al
	
docker container run -it --rm -v hostvol:/mnt/hostvol --name ubuntu01 ubuntu:18.04 bash
	cd /mnt/hostvol
	echo "Created by ubuntu01" >> ubuntu01.txt
	ls -al

//NFS Volume attach
docker volume create --driver local --opt type=nfs --opt o=addr=218.145.56.74,rw --opt device=:/localdata/nfs_kube nfsvol
docker volume ls
docker volume inspect nfsvol

docker container run -it --rm -v nfsvol:/mnt/nfsvol --name ubuntu02 ubuntu:18.04 bash
	cd /mnt/nfsvol
	echo "Created by ubuntu02" >> ubuntu02-nfs.txt
	ls -al
	
docker container run -it --rm -v nfsvol:/mnt/nsfvol --name ubuntu03 ubuntu:18.04 bash
	cd /mnt/nfsvol
	echo "Created by ubuntu03" >> ubuntu03-nfs.txt
	ls -al

//기타 Advanced Topic
docker container run -d -p 8280:80 -v /webdata:/usr/local/apache2/htdocs:ro --name web8280 httpd:latest

docker container run -d -p 8280:80 -v /usr/local/apache2/htdocs --name web8280 httpd:latest

docker inspect web8280
        "Mounts": [
            {
                "Type": "volume",
                "Name": "9129131b058b6568acfeab6293315929dd34f6bb86408e0737409d206dcd12ab",
                "Source": "/var/lib/docker/volumes/9129131b058b6568acfeab6293315929dd34f6bb86408e0737409d206dcd12ab/_data",
                "Destination": "/usr/local/apache2/htdocs",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            }

//아래 명령은 volume만큼은 지우지 않아요. 지우려면 docker volume prune -->주의, 주의, 경고,...

docker system prune -a
WARNING! This will remove:
  - all stopped containers
  - all networks not used by at least one container
  - all images without at least one container associated to them
  - all build cache

Are you sure you want to continue? [y/N]

docker volume prune
docker volume rm nfsvol



//단일 호스트에서 콘테이너간 파일 공유 예)
docker run -v /wwwdocs:/wwwdocs -d -p 8081:8080 --name mbkahk_wwwdev mkbahk/tensorflow:code-server-8080 code-server
docker run -v /wwwdocs:/usr/local/apache2/htdocs:ro -d -p 8082:80 --name wwwprod httpd:latest

docker run -it -d -v /root/webdata:/usr/share/nginx/html mkbahk/ubuntu-genhtml:latest
docker run -it -d -v /root/webdata:/usr/share/nginx/html -p 8780:80 nginx:latest


=====================================================================================
docker container에 특정 Device 마운트
=====================================================================================
//docker가 HOST의 특정 장치를 사용하도록 하는 명령
docker run --rm --gpus all nvidia/cuda:10.0-devel-ubuntu18.04 nvidia-smi

NV_GPU=0,1 nvidia-docker run -it nvcr.io/nvidia/tensorflow:20.12-tf1-py3
docker run -it --runtime=nvidia -e NVIDIA_VISIBLE_DEVICES=2,3 nvcr.io/nvidia/tensorflow:20.12-tf1-py3
docker run -it --gpus '"device=0,1,2,3"' nvcr.io/nvidia/tensorflow:20.12-tf1-py3

docker run --device=/dev/ipu0:/dev/ipu0 --device=/dev/ipu0_ex:/dev/ipu0_ex --device=/dev/ipu0_mailbox:/dev/ipu0_mailbox --device=/dev/ipu0_mem:/dev/ipu0_mem -ti graphcore/tools gc-inventory
gc-docker --device-id 0 -- -ti graphcore/tools gc-inventory

=====================================================================================
docker Network
=====================================================================================

mkbahk@srv161:~$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
64e80fa4479d        bridge              bridge              local
4b176f181bbe        host                host                local
eaaaae84e98b        none                null                local
mkbahk@srv161:~$ docker network inspect 64e80fa4479d
[
    {
        "Name": "bridge",
        "Id": "64e80fa4479d51da3e9aedb79641a90e2e39b617218f17605f06506332f23ea6",
        "Created": "2022-06-04T15:03:11.399057009+09:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": null,
            "Config": [
                {
                    "Subnet": "172.17.0.0/16",
                    "Gateway": "172.17.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "1c23d0c7e4dab5f889a67cee5b0d22ea1008de997f6d26c550bb47c67453b0ba": {
                "Name": "mysql",
                "EndpointID": "ce2195bcc525c3c6761577990e6110b8b9c7733d26cc123a9d069d700e6e40b6",
                "MacAddress": "02:42:ac:11:00:02",
                "IPv4Address": "172.17.0.2/16",
                "IPv6Address": ""
            },
            "2f3348856598ef4ebfea80acb4d3aec351d34ddb21ebf89bf93787e37ea23b1e": {
                "Name": "postgres",
                "EndpointID": "60e2146aaff522542fbd3b138236d6edcf48baefac325b5a50747792755f959d",
                "MacAddress": "02:42:ac:11:00:04",
                "IPv4Address": "172.17.0.4/16",
                "IPv6Address": ""
            },
            "c8496394df37706f1708e03bd5bfd7418673a2c0b6d7819a5e8fbb4f8352c79b": {
                "Name": "wordpress",
                "EndpointID": "64b59e31d0f4e5215a249928078ecafe1bbf8d324a99d08b21a6c5fbd61fa36e",
                "MacAddress": "02:42:ac:11:00:03",
                "IPv4Address": "172.17.0.3/16",
                "IPv6Address": ""
            }
        },
        "Options": {
            "com.docker.network.bridge.default_bridge": "true",
            "com.docker.network.bridge.enable_icc": "true",
            "com.docker.network.bridge.enable_ip_masquerade": "true",
            "com.docker.network.bridge.host_binding_ipv4": "0.0.0.0",
            "com.docker.network.bridge.name": "docker0",
            "com.docker.network.driver.mtu": "1500"
        },
        "Labels": {}
    }
]


docker network create ubuntu-network
docker network ls
docker network inspect ubuntu-network

//터미널 창을 2개 여세요. 각각의 창에
창1: 
docker container run --rm -it --name ubuntu01 --network ubuntu-network ubuntu:18.04 bash

창2:
docker container run --rm -it --name ubuntu02 --network ubuntu-network ubuntu:18.04 bash

//두개의 ubuntu:18.04 컨테이너에 아래 명령들을 수행해 ip관련 툴들을 설치합니다.

	apt update -y
	apt install iputils-ping -y   	//ping 툴 설치
	apt install net-tools -y 		//ifconfig 툴 설치
	apt install iproute2 -y 		// ip commands 들 설치

각각의 창에서
	ifconfig
	ip a
	ip route
	netstat -nltp
	netstat --route
	ping ubuntu01
	ping ubuntu02
	ping ubuntu01.ubuntu-network
	ping ubuntu02.ubuntu-network

//창3 새로 여세요
docker container run --rm -it --name ubuntu03 ubuntu:18.04 bash
	apt update -y
	apt install iputils-ping -y   	
	apt install net-tools -y 		
	apt install iproute2 -y 		
	ifconfig

docker network connect ubuntu-network ubuntu03

//ubuntu03 container 내부에서
	ping ubuntu01
	ping ubuntu02


//HOST창에서
docker network disconnect bridge ubuntu03

//ubuntu03 창에서
ifconfig

//특정 도커에 static IP 설정 방법

docker network create --driver bridge --subnet 192.168.255.0/24 --gateway 192.168.255.254 hello-world.net
docker run -d --name nginx-web --network hello-world.net --ip 192.168.255.200 -p 8384:80 nginx:latest

=====================================================================================
Docker 외부서비스 포트 오픈 방법
=====================================================================================
//컨터이너와 외부서비스를 위한 포트 매칭 및 Port-Forwarding 3가지 방법
docker container run --name nginx1 -d -p 8080:80 nginx:latest
docker container run --name nginx1 -d -p 80 nginx:latest ##호스트의 사용하지 않는 램덤포트를 콘테이너 내부 80퐅에 매핑
docker container run --name nginx1 -d -P nginx:latest  ##콘테이너 내부의 모든 포트를 호스트의 임의의 포트로 매핑, 대문자 "P" 입니다.

docker container run --name nginx1 -d -p 8080:80 -p 5050:5000 nginx:latest
docker container run --name nginx1 -d -p 8080-8089:80 nginx:latest ##8080~8090 중 하나를 내부 80포트에 매핑


=====================================================================================
Dockerfile
=====================================================================================

mkdir -p prj-docfile-hellonodejs
cd prj-docfile-hellonodejs

//hello-p7777.js 파일 만들기
vi hello-p7777.js
var os = require('os');

var http = require('http');
var handleRequest = function(request, response) {
  response.writeHead(200);
  response.end("What's up, man! I'm "+os.hostname()+", running by Moon-Kee Bahk.");
  //log
  console.log("["+Date(Date.now()).toLocaleString()+"] "+os.hostname());
}

var www = http.createServer(handleRequest);
www.listen(7777);

:wq!


//Dockerfile 만들기
vi Dockerfile
FROM node:latest
EXPOSE 7777
COPY hello-p7777.js .
CMD node hello-p7777.js > log.out

:wq!

//Docker image 생성하기
docker build . -t mkbahk/hellonodejs:1.0

//수행
docker run -it -d -p 7777:7777 mkbahk/hellonodejs:1.0

//외부 브라우저에서 접속
http://ip_address:7777/

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//smartcar training & inferece 환경구축 및 최종 실행을 Dockerfile 하나로 묶는 방법
##원래는 이러한 순서데로 개발환경을 만들어 갔을 것입니다. 

docker run -it --name SmartCar ubuntu:18.04 bash
  apt update -y
  apt install iputils-ping -y   	
  apt install net-tools -y 		
  apt install iproute2 -y  
  apt install curl wget nano -y

  apt install software-properties-common -y
  add-apt-repository ppa:deadsnakes/ppa -y
  apt update -y
  apt install python3.8 -y
  apt install python3-pip -y
  pip3 install -U pip -q
  pip3 install tensorflow==2.6.2 -q
  pip3 install keras -q
  pip3 install pandas -q
  pip3 install matplotlib -q
  pip3 install sklearn -q
  pip3 install flask -q

  apt install git -y
  cd /root
  git clone https://github.com/mkbahk/IPULearning -q
  cd /root/IPULearning/SmartCar/
python3 /root/IPULearning/SmartCar/smartcar_dnn_model.py
python3 /root/IPULearning/SmartCar/smartcar_dnn_service_2.py

//다른 창에서
curl -X GET "http://172.17.0.2:9002/smartcar/predict?wea=2&temp=0&hum=1&arrOthCar=2&time=0&acciArea=1&drvCond=1&innCond=2&carSpd=2&SteeAng=0"

//docker service로 실행하기기
docker run -it -d -p 9002:9002 mkbahk/smartcar:1.1 python3 /root/IPULearning/SmartCar/smartcar_dnn_service_2.py
docker container ls 

//접근, 다른 창에서
curl -X GET "http://172.17.0.2:9002/smartcar/predict?wea=2&temp=0&hum=1&arrOthCar=2&time=0&acciArea=1&drvCond=1&innCond=2&carSpd=2&SteeAng=0"
또는 브라우저에서
http://ip_address:9002/smartcar/predict?wea=2&temp=0&hum=1&arrOthCar=2&time=0&acciArea=1&drvCond=1&innCond=2&carSpd=2&SteeAng=0

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//Dockerfile을 이용해 docker build명령으로 이미지를 자동생성해 보겠습니다.

cd
git clone https://github.com/mkbahk/DockerLearning
cd ./DockerLearning/prj-docfile-SmartCar/
ls -al

cat Dockerfile

#docker build . -t mkbahk/smartcar:0.1
FROM ubuntu:18.04
EXPOSE 9002
RUN apt update -y
RUN apt install iputils-ping -y
RUN apt install net-tools -y
RUN apt install iproute2 -y
RUN apt install curl wget nano -y
RUN apt install software-properties-common -y
RUN add-apt-repository ppa:deadsnakes/ppa -y
RUN apt update -y
RUN apt install python3.8 -y
RUN apt install python3-pip -y
RUN pip3 install -U pip -q
RUN pip3 install tensorflow==2.6.2 -q
RUN pip3 install keras -q
RUN pip3 install pandas -q
RUN pip3 install matplotlib -q
RUN pip3 install sklearn -q
RUN pip3 install flask -q
RUN apt install git -y
RUN git clone https://github.com/mkbahk/DockerLearning /root/DockerLearning
#RUN ls -al /root/DockerLearning/prj-docfile-SmartCar/
#RUN python3 --version
RUN python3 /root/DockerLearning/prj-docfile-SmartCar/smartcar_dnn_model.py
RUN echo "Hello guys!!!"
RUN echo "Execute cmd: docker run -d -p 9002:9002 mkbahk/smartcar:0.1"
RUN echo "and ..."
RUN echo 'Access with: curl -X GET "http://srv161:9002/smartcar/predict?wea=2&temp=0&hum=1&arrOthCar=2&time=0&acciArea=1&drvCond=1&innCond=2&carSpd=2&SteeAng=0"'
#
CMD python3 /root/DockerLearning/prj-docfile-SmartCar/smartcar_dnn_service_2.py
#


//이미지 생성
docker system prune -a
docker build . -t mkbahk/smartcar:0.1
docker image ls


//서비스로 기동
docker run -d -p 9002:9002 mkbahk/smartcar:0.1

//서비스 기동 확인
docker container ls

//외부로 부터, 다른 창에서 접근
curl -X GET "http://ip_address:9002/smartcar/predict?wea=2&temp=0&hum=1&arrOthCar=2&time=0&acciArea=1&drvCond=1&innCond=2&carSpd=2&SteeAng=0"

또는 브라우저에서

http://ip_address:9002/smartcar/predict?wea=2&temp=0&hum=1&arrOthCar=2&time=0&acciArea=1&drvCond=1&innCond=2&carSpd=2&SteeAng=0




=====================================================================================
Docker-compose: 컨테이너 정의
=====================================================================================
//docker-compose 설치
sudo curl -L https://github.com/docker/compose/releases/download/1.29.2/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
docker-compose --version
cd /usr/bin
ls -s /usr/local/bin/docker-compose docker-compose

docker-compose --version
	docker-compose version 1.29.2, build 5becea4c

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

mkdir -p ./prj-doccomp-mysql-phpadmin-wordpress
cd  prj-doccomp-mysql-phpadmin-wordpress/

vi docker-compose.yaml

version: '3'

services:
  # Database
  db:
    image: mysql:5.7
    volumes:
      - ./db_data:/var/lib/mysql
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: password
      MYSQL_DATABASE: wordpress
      MYSQL_USER: wordpress
      MYSQL_PASSWORD: wordpress
    networks:
      - wpsite-network
  # phpmyadmin
  phpmyadmin:
    depends_on:
      - db
    image: phpmyadmin/phpmyadmin
    restart: always
    ports:
      - '8181:80'
    environment:
      PMA_HOST: db
      MYSQL_ROOT_PASSWORD: password
    networks:
      - wpsite-network
  # Wordpress
  wordpress:
    depends_on:
      - db
    image: wordpress:latest
    ports:
      - '8282:80'
    restart: always
    volumes: ['./wp:/var/www/html']
    environment:
      WORDPRESS_DB_HOST: db:3306
      WORDPRESS_DB_USER: wordpress
      WORDPRESS_DB_PASSWORD: wordpress
    networks:
      - wpsite-network
networks:
  wpsite-network:
volumes:
  db_data:


docker-compose up -d
docker-compose ps
docker container ls


http://ip_address:8282/
  docker learing blog
  admin
  admin
  V약한 비밀번호 사용 확인
  admin@helloworld.net

http://ip_address:8181/
  wordpress
  wordpress

docker-compose down
cd


=====================================================================================
Docker-compose scale up/down
=====================================================================================
mkdir -p ./prj-doccomp-nginx-scale
cd ./prj-doccomp-nginx-scale

vi docker-compose.yaml

version : "3"
services:
   web:
      image: "nginx:latest"
      ports:
         - "8380-8389:80"
      networks:
         - nginx-net
networks:
   nginx-net:

docker-compose up -d --scale web=10
docker-compose ps
docker container ls

http://ip_address:8380/
~
http://ip_address:8389/

docker-compose up -d --scale web=3

docker stop 명령으로 3개 중 하나를 죽입니다. #자동복구가 않됩니다. 수동 scale명령으로 다시 조정해야 합니다. docker stack은 자동복구 가능

docker-compose down
cd

=====================================================================================
Docker swarm
=====================================================================================

//master에서만만만
docker swarm init --advertise-addr 192.168.56.202

root@master202:~# docker swarm init --advertise-addr 192.168.56.202
Swarm initialized: current node (sbwsg73qvndqk2uw3zpm9st3u) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join --token SWMTKN-1-3vg6jgq3kz4wk7vf063grdlclszkfcuhppzxwzib93apxo5dsv-dbsqamlo8084k3hyx3gl4blws 192.168.56.202:2377

To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.

root@master202:~#



//worker들에서
docker swarm join --token SWMTKN-1-3vg6jgq3kz4wk7vf063grdlclszkfcuhppzxwzib93apxo5dsv-dbsqamlo8084k3hyx3gl4blws 192.168.56.202:2377

root@master202:~# docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
sbwsg73qvndqk2uw3zpm9st3u *   master202           Ready               Active              Leader              19.03.8
j0a4fe3pauhsh485j9rqizznm     worker203           Ready               Active                                  19.03.8
ma3svopcv53k52mv5so4y4qen     worker204           Ready               Active                                  19.03.8
root@master202:~#


//scale 실습
git clone https://github.com/mkbahk/nginxscale
cd nginxscale
docker build . -t mkbahk/nginxscale:1.0

root@master202:~/nginxscale# docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE
mkbahk/nginxscale   1.0                 95648d2afd8a        About a minute ago   142MB


docker service create --name web --publish 8380:80 --mode global mkbahk/nginxscale:1.0
//주로 호스트 로그수집기, 모니터링 에이전트와 같은 프로그램 실행 시 적용


root@master202:~# docker service ls
ID                  NAME                MODE                REPLICAS            IMAGE                   PORTS
y5dyik5vczo7        web                 global              3/3                 mkbahk/nginxscale:1.0   *:8380->80/tcp

http://192.168.56.202:8380
http://192.168.56.203:8380
http://192.168.56.204:8380

docker service rm y5

docker container ls
docker container ls -a

//서비스에 소속된 컨테이너 삭제 테스트
3개 워커 중 하나의 워커에서 docker stop 명령으로 강제로 삭제 후 다시 서비스가 살아나는 것을 확인
docker container stop ...
docker container ls



docker service create --name web --publish 8380:80 --replicas 6 mkbahk/nginxscale:1.0 
docker service ls
docker container ls   //모든 호스트에서 쳐보세요.

http://192.168.56.202:8380

docker service scale web=12
docker service rm web

docker rm -f $(docker ps -q -aq)  


=====================================================================================
Docker stack : 서비스 정의
=====================================================================================
//docker-compose vs. docker stack
docker-compose는 container를 정의하는 것이고, docker stack는 service를 정의하는 것이다.

service라는 개념은 docker version 1.12 이후 도입된 개념이다.

docker-compose는 컨테이너를 정의하는 것이기 때문에, docker-compose 명령이 실행되는 순간에만 컨테이너의 상태가 올바른지 확인 후, 컨테이너가 켜져 있지 않으면 컨테이너를 실행시키고 docker-compose의 몫은 끝난다.
docker-compose는 상태를 지속적으로 모니터링 하지 않기 때문에 만약 컨테이너가 5분안에 예기치 않게 종료 되면, compose는 컨테이너를 다시 시작하지 못한다.

하지만 docker stack은 docker 엔진의 원하는 서비스 상태를 항상 알수 있으며, 그렇기 때문에 엔진이 원하는 서비스 상태와 지금 서비스 상태가 다르다면 조치도 가능하다

예를 들어 컨테이너가 죽으면 다른 컨테이너를 호출 하거나, 전체노드에서 컨테이너를 몇개 가져가면 엔진을 감지하여 컨테이너를 정상적인 노드로 다시 가져올 수 있다. 즉, docker stack은 docker-compose에서 지원하지 않는 모니터링과 그에 따른 조치 기능을 제공하는 것이 큰 차이점이다. 

git clone https://github.com/mkbahk/DockerLearning
cd DockerLearning/prj-docstack-nginx-scale

cat docker-compose.yaml

version : "3"
services:
   stackweb:
      image: "nginx:latest"
      deploy:
         replicas: 5
         restart_policy:
            condition: on-failure
         resources:
           limits:
             cpus: "0.1"
             memory: 50M
      ports:
         - "8180:80"
      networks:
         - nginx-net
networks:
   nginx-net:


docker stack deploy -c docker-compose.yaml nginxstack

docker stack ls
docker container ls //모든 swarm worker들에서 확인해 보세요.

//워커들 중 서비스가 떠 있는 곳에서
docker container stop ... //명령으로 1~2개 강제로 stop시킨 후 서비스 복구를 확인하세요.
docker stack services nginxstack
docker container ls

//docker stack은 docker service 명령을 .yaml로 바꾼형태입니다. 결국 이 .yaml 파일이 kubernetes에서 메인으로 사용하게 됩니다.

docker stack ls
docker stack rm nginxstack


=====================================================================================
CI/CD 중 Jenkins를 이용한 CI 구현CI->Docker+github.com+dockerhub.com+Jenkins, CD->Kubernetes
=====================================================================================


docker run -u root -d --restart=always -p 8282:8080 -v /root/jenkins:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v /usr/bin/docker:/usr/bin/docker  jenkins/jenkins:latest

http://srv161:8282/
Username: admin
Password: admin


docker run -u root  -p 8282:8080 -v /root/jenkins:/var/jenkins_home -v /run/docker.sock:/run/docker.sock -v /usr/bin/docker:/usr/bin/docker  jenkins/jenkins:latest

a6bbdb247ef2433c8dec708aeb3ee95c


//jenkins docker sample
//github의 branch의 default name이  main이면 문제가 발생함. main->master로 rename하면 문제가 해결됨. 최근에 github에서 master branch이름을 main으로 변경함으로써 미처 사용 응용프로그램들이 딸아오지 못해서 발생함


Program과 수행환경은 Dockerfile or docker-compose.yaml로 만들어 놓은 후

git clone https://github.com/mkbahk/nginxscale.git
docker build --force-rm=true -t mkbahk/nginxscale:latest .    
docker tag mkbahk/nginxscale:latest mkbahk/nginxscale:2.1

docker login -u mkbahk -p "P@ssw0rd"'
docker push mkbahk/nginxscale:2.1
docker push mkbahk/nginxscale:latest

docker stop nginxscale
docker rm nginxscale
docker run -d -p 8380:80 --name=nginxscale mkbahk/nginxscale:latest
	

//jenkin pipeline
node {
	stage('Pull') {
	}
	stage('Unit Test') {
	}
	stage('Build') {
	}
	stage('Tag') {
	}
	stage('Push') {
	}
	stage('Deploy') {
	}
}

//Basic Step
node {
    stage('Git Pull') {
        git 'https://github.com/mkbahk/nginxscale.git'
    }
    stage('Unit Test') {  
        try  {
          sh(script: 'docker image rm mkbahk/nginxscale:latest')  
        } 
        catch(e) {
            echo "No nginxscale container to remove"
        }
    }
    stage('Docker Build') {
        sh(script: 'docker build --force-rm=true -t mkbahk/nginxscale:latest .')    
    }
    stage('Change Tag') {
        sh(script: 'docker tag mkbahk/nginxscale:latest mkbahk/nginxscale:2.1')
    }
    stage('Push to Dockerhub') {
        sh(script: 'docker login -u mkbahk -p "P@ssW0rd"' )
        sh(script: 'docker push mkbahk/nginxscale:2.1' )
        sh(script: 'docker push mkbahk/nginxscale:latest' )
    }
    stage('Deploy as a Service') {
        try {
            sh(script: 'docker stop nginxscale')
            sh(script: 'docker rm nginxscale')
        } catch(e) {
            echo "No nginxscale container exists"
        }
        sh(script: 'docker run -d -p 8380:80 --name=nginxscale mkbahk/nginxscale:latest')
    }
}

//Basic Step#2
node {
    withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: 'dockerhub', usernameVariable: 'DOCKER_USER_ID', passwordVariable: 'DOCKER_USER_PASSWORD']]) {
        stage('Pull') {
            git 'https://github.com/mkbahk/nginxscale.git'
        }
        stage('Unit Test') {
            try  {
              sh(script: 'docker image rm mkbahk/nginxscale:latest')  
            } 
            catch(e) {
                echo "No nginxscale container to remove"
            }
        }
        stage('Build') {
            sh(script: 'docker build --force-rm=true -t mkbahk/nginxscale:latest .')    
        }
        stage('Tag') {
            sh(script: 'docker tag ${DOCKER_USER_ID}/nginxscale:latest ${DOCKER_USER_ID}/nginxscale:0.${BUILD_NUMBER}')
        }
        stage('Push') {
            sh(script: 'docker login -u ${DOCKER_USER_ID} -p ${DOCKER_USER_PASSWORD}')
            sh(script: 'docker push ${DOCKER_USER_ID}/nginxscale:0.${BUILD_NUMBER}')
            sh(script: 'docker push ${DOCKER_USER_ID}/nginxscale:latest')
        }
        stage('Deploy') {
            try {
                sh(script: 'docker stop nginxscale')
                sh(script: 'docker rm nginxscale')
            } catch(e) {
                echo "No nginxscale container exists"
            }
            sh(script: 'docker run -d -p 8380:80 --name=nginxscale ${DOCKER_USER_ID}/nginxscale:0.${BUILD_NUMBER}')
        }
    }
}


 sh(script: 'docker service update --replicas=6 --name=nginxweb mkbahk/nginxscale:0.${BUILD_NUMBER}')


//Docker-compose
node {
	stage('Pull') {
		git 'https://github.com/mkbahk/nginxscale.git'
	}
	stage('Unit Test') {
		sh(script: 'docker-compose run --rm unit')
	}
	stage('Build') {
		sh(script: 'docker-compose build app')
	}
	stage('Tag') {
		// 생략 ...
	}
	stage('Push') {
		// 생략 ...
	}
	stage('Deploy') {
		sh(script: 'docker-compose up -d production')
	}
}

//docker swarm 배포
docker service update --image mkbahk/nginxscale:${BUILD_NUMBER} web-app

sh(script: 'docker service update --publish 8380:80 --replicas 6 --name=nginxweb --image nginxscale:0.${BUILD_NUMBER}')


//Kubernetes 배포
kubectl set image -f nginx-scale.yml app=mkbahk/nginxscale:${BUILD_NUMBER}


=====================================================================================
(참고) Docker and IPTables
=====================================================================================
//Docker는 기본적으로 iptables 기능을 통해 host외부로 통신
//iptable은 L-3 Routing, NAT(Network Address Translation), Firewall 역할을 수행
//모든 도커 설정이 이상이 없는데, 이상하게 않될 경우는 iptables의 테이블을 reset해 본다.

iptables -L

iptables -F 

//문제가 있는 경우 아래와 같은 메세지 출력
root@srv162:/var/lib/docker/containers# docker run -d -it -p 8484:80 --name nginx nginx:latest
7fd353671ba4721216ec1512152b38b2e773a359c88c26247565664fe5421340
docker: Error response from daemon: driver failed programming external connectivity on endpoint nginx (b8a1ca53f0ad48fa8b62408cfe705c93387cd63d0279529a5dba1110f40da17e):  (iptables failed: iptables --wait -t filter -A DOCKER ! -i docker0 -o docker0 -p tcp -d 172.17.0.2 --dport 80 -j ACCEPT: iptables: No chain/target/match by that name.
 (exit status 1)).



root@srv162:~# iptables -F

 //해결방법
systemctl restart docker 

iptables -L


root@srv162:~# iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination

Chain DOCKER (0 references)
target     prot opt source               destination

Chain DOCKER-ISOLATION-STAGE-1 (0 references)
target     prot opt source               destination

Chain DOCKER-ISOLATION-STAGE-2 (0 references)
target     prot opt source               destination

Chain DOCKER-USER (0 references)
target     prot opt source               destination

Chain f2b-sshd (0 references)
target     prot opt source               destination


root@srv162:~# systemctl restart docker


root@srv162:~# iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination
DOCKER-USER  all  --  anywhere             anywhere
DOCKER-ISOLATION-STAGE-1  all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED
DOCKER     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination

Chain DOCKER (1 references)
target     prot opt source               destination

Chain DOCKER-ISOLATION-STAGE-1 (1 references)
target     prot opt source               destination
DOCKER-ISOLATION-STAGE-2  all  --  anywhere             anywhere
RETURN     all  --  anywhere             anywhere

Chain DOCKER-ISOLATION-STAGE-2 (1 references)
target     prot opt source               destination
DROP       all  --  anywhere             anywhere
RETURN     all  --  anywhere             anywhere

Chain DOCKER-USER (1 references)
target     prot opt source               destination
RETURN     all  --  anywhere             anywhere

Chain f2b-sshd (0 references)
target     prot opt source               destination
root@srv162:~#


// iptables 확인
docker container run -d -p 8090:80 --name mkbahk-web nginx:1.14
docker container ls
iptables -t nat -L -n -v

Chain DOCKER (2 references)
 pkts bytes target     prot opt in     out     source               destination
    0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0
    0     0 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:8383 to:172.17.0.2:80

=====================================================================================
                                End of Documents
=====================================================================================